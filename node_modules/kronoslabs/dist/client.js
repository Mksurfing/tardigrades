"use strict";
/**
 * Kronos Labs API Client
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KronosLabs = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const errors_1 = require("./errors");
/**
 * Chat completions API
 */
class ChatCompletions {
    constructor(client) {
        this.client = client;
    }
    /**
     * Create a chat completion
     */
    async create(params) {
        const { messages = [], prompt, model = "hyperion", temperature = 0.7, isStream = false, tool = false, } = params;
        // Validate model
        const validModels = ["hyperion", "hermes"];
        if (!validModels.includes(model)) {
            throw new errors_1.KronosLabsError(`Invalid model '${model}'. Must be one of: ${validModels.join(", ")}`);
        }
        // Validate tool usage
        if (model === "hyperion" && tool) {
            throw new errors_1.KronosLabsError(`Model '${model}' does not support tool calling.`);
        }
        const payload = {
            messages,
            prompt,
            temperature,
            is_stream: isStream,
            tool,
        };
        if (isStream) {
            return this.streamCompletion(payload, model);
        }
        else {
            return this.createCompletion(payload, model);
        }
    }
    /**
     * Create a non-streaming chat completion
     */
    async createCompletion(payload, model) {
        const response = await this.client.post(`/api/chat/${model}`, payload);
        return response;
    }
    /**
     * Create a streaming chat completion
     */
    async streamCompletion(payload, model) {
        const response = await this.client.postStream(`/api/chat/${model}`, payload);
        return this.parseStreamResponse(response);
    }
    /**
     * Parse streaming response
     */
    async *parseStreamResponse(response) {
        if (!response.body) {
            throw new errors_1.KronosLabsError("Response body is empty");
        }
        const reader = response.body;
        let buffer = "";
        for await (const chunk of reader) {
            buffer += chunk.toString();
            const lines = buffer.split("\n");
            // Keep the last incomplete line in the buffer
            buffer = lines.pop() || "";
            for (const line of lines) {
                const trimmedLine = line.trim();
                // Skip empty lines and [DONE] message
                if (!trimmedLine || trimmedLine === "data: [DONE]") {
                    continue;
                }
                // Remove 'data: ' prefix
                let jsonStr = trimmedLine;
                if (jsonStr.startsWith("data: ")) {
                    jsonStr = jsonStr.slice(6);
                }
                try {
                    const data = JSON.parse(jsonStr);
                    yield data;
                }
                catch (error) {
                    // Skip invalid JSON
                    continue;
                }
            }
        }
    }
}
/**
 * Chat API
 */
class Chat {
    constructor(client) {
        this.completions = new ChatCompletions(client);
    }
}
/**
 * Kronos Labs API Client
 *
 * @example
 * ```typescript
 * const client = new KronosLabs({ apiKey: 'your-api-key' });
 * const response = await client.chat.completions.create({
 *   prompt: 'Hello, how are you?',
 *   temperature: 0.7
 * });
 * console.log(response.choices[0].message.content);
 * ```
 */
class KronosLabs {
    constructor(config) {
        if (!config.apiKey) {
            throw new errors_1.AuthenticationError("API key is required");
        }
        this.apiKey = config.apiKey;
        this.baseUrl = config.baseUrl || KronosLabs.DEFAULT_BASE_URL;
        this.chat = new Chat(this);
    }
    /**
     * Get headers for API requests
     */
    getHeaders() {
        return {
            "Content-Type": "application/json",
            "X-API-Key": this.apiKey,
        };
    }
    /**
     * Make a POST request to the API
     */
    async post(endpoint, data) {
        const url = `${this.baseUrl}${endpoint}`;
        const headers = this.getHeaders();
        try {
            const response = await (0, node_fetch_1.default)(url, {
                method: "POST",
                headers,
                body: JSON.stringify(data),
            });
            if (response.status === 401) {
                throw new errors_1.AuthenticationError("Invalid API key");
            }
            if (!response.ok) {
                let errorMessage = `API request failed with status ${response.status}`;
                try {
                    const errorData = await response.json();
                    errorMessage = errorData.error || errorMessage;
                }
                catch {
                    // Ignore JSON parse errors
                }
                throw new errors_1.KronosLabsError(errorMessage, response.status);
            }
            return await response.json();
        }
        catch (error) {
            if (error instanceof errors_1.KronosLabsError) {
                throw error;
            }
            throw new errors_1.KronosLabsError(`Request failed: ${error}`);
        }
    }
    /**
     * Make a streaming POST request to the API
     */
    async postStream(endpoint, data) {
        const url = `${this.baseUrl}${endpoint}`;
        const headers = this.getHeaders();
        try {
            const response = await (0, node_fetch_1.default)(url, {
                method: "POST",
                headers,
                body: JSON.stringify(data),
            });
            if (response.status === 401) {
                throw new errors_1.AuthenticationError("Invalid API key");
            }
            if (!response.ok) {
                let errorMessage = `API request failed with status ${response.status}`;
                try {
                    const errorData = await response.json();
                    errorMessage = errorData.error || errorMessage;
                }
                catch {
                    // Ignore JSON parse errors
                }
                throw new errors_1.KronosLabsError(errorMessage, response.status);
            }
            return response;
        }
        catch (error) {
            if (error instanceof errors_1.KronosLabsError) {
                throw error;
            }
            throw new errors_1.KronosLabsError(`Request failed: ${error}`);
        }
    }
}
exports.KronosLabs = KronosLabs;
KronosLabs.DEFAULT_BASE_URL = "https://kronoslabs.org";
